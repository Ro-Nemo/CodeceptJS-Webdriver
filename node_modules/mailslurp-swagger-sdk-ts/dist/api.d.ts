/**
 * MailSlurp API
 * ## Introduction  [MailSlurp](https://www.mailslurp.com) is an Email API for developers and QA testers. It let's users: - create emails addresses on demand - receive emails and attachments in code - send templated HTML emails  ## About  This page contains the REST API documentation for MailSlurp. All requests require API Key authentication passed as an `x-api-key` header.  Create an account to [get your free API Key](https://app.mailslurp.com/sign-up/).  ## Resources - üîë  [Get API Key](https://app.mailslurp.com/sign-up/)                    - üéì [Developer Portal](https://www.mailslurp.com/developers/)           - üì¶ [Library SDKs](https://www.mailslurp.com/developers/integrations/) - ‚úçÔ∏è [Code Examples](https://github.com/mailslurp/examples) - ‚ö†Ô∏è [Report an issue](https://drift.me/mailslurp)  ## Explore
 *
 * OpenAPI spec version: 6.5.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/// <reference path="../custom.d.ts" />
import { Configuration } from "./configuration";
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
/**
 *
 * @export
 * @interface AttachmentMetaData
 */
export interface AttachmentMetaData {
    /**
     *
     * @type {number}
     * @memberof AttachmentMetaData
     */
    contentLength: number;
    /**
     *
     * @type {string}
     * @memberof AttachmentMetaData
     */
    contentType: string;
    /**
     *
     * @type {string}
     * @memberof AttachmentMetaData
     */
    name: string;
}
/**
 *
 * @export
 * @interface BasicAuthOptions
 */
export interface BasicAuthOptions {
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    password: string;
}
/**
 * Bulk sending options
 * @export
 * @interface BulkSendEmailOptions
 */
export interface BulkSendEmailOptions {
    /**
     * Inboxes to send from
     * @type {Array<string>}
     * @memberof BulkSendEmailOptions
     */
    inboxIds?: Array<string>;
    /**
     *
     * @type {SendEmailOptions}
     * @memberof BulkSendEmailOptions
     */
    sendEmailOptions: SendEmailOptions;
}
/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it.
 * @export
 * @interface CreateDomainOptions
 */
export interface CreateDomainOptions {
    /**
     * The top level domain you wish to use with MailSlurp
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domain?: string;
}
/**
 *
 * @export
 * @interface CreateWebhookOptions
 */
export interface CreateWebhookOptions {
    /**
     *
     * @type {BasicAuthOptions}
     * @memberof CreateWebhookOptions
     */
    basicAuth?: BasicAuthOptions;
    /**
     * Public URL (including protocol) that MailSlurp can post WebhookNotificationObjects to when an email is received
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    url?: string;
    /**
     *
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    name?: string;
}
/**
 *
 * @export
 * @interface DomainPlusVerificationRecordsAndStatus
 */
export interface DomainPlusVerificationRecordsAndStatus {
    /**
     *
     * @type {Date}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    id: string;
    /**
     *
     * @type {Date}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    userId: string;
    /**
     *
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    verificationToken: string;
    /**
     *
     * @type {boolean}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    verified: boolean;
}
/**
 * Preview object for domain entity
 * @export
 * @interface DomainPreview
 */
export interface DomainPreview {
    /**
     *
     * @type {Date}
     * @memberof DomainPreview
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    id: string;
}
/**
 * Representation of an email
 * @export
 * @interface Email
 */
export interface Email {
    /**
     *
     * @type {EmailAnalysis}
     * @memberof Email
     */
    analysis?: EmailAnalysis;
    /**
     *
     * @type {Array<string>}
     * @memberof Email
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof Email
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    body?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Email
     */
    cc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    charset?: string;
    /**
     *
     * @type {Date}
     * @memberof Email
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    from?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    headers?: {
        [key: string]: string;
    };
    /**
     *
     * @type {boolean}
     * @memberof Email
     */
    html?: boolean;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    rawUrl?: string;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Email
     */
    to: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof Email
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof Email
     */
    userId: string;
}
/**
 * Analysis of email
 * @export
 * @interface EmailAnalysis
 */
export interface EmailAnalysis {
    /**
     *
     * @type {string}
     * @memberof EmailAnalysis
     */
    dkimVerdict?: string;
    /**
     *
     * @type {string}
     * @memberof EmailAnalysis
     */
    dmarcVerdict?: string;
    /**
     *
     * @type {string}
     * @memberof EmailAnalysis
     */
    spamVerdict?: string;
    /**
     *
     * @type {string}
     * @memberof EmailAnalysis
     */
    spfVerdict?: string;
    /**
     *
     * @type {string}
     * @memberof EmailAnalysis
     */
    virusVerdict?: string;
}
/**
 * Preview of an email message. For full message call the email endpoints with the provided email id.
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    bcc?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof EmailPreview
     */
    created: Date;
    /**
     *
     * @type {Date}
     * @memberof EmailPreview
     */
    createdAt: Date;
    /**
     * ID of the Email.
     * @type {string}
     * @memberof EmailPreview
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    to: Array<string>;
}
/**
 *
 * @export
 * @interface EmailProjection
 */
export interface EmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    attachments: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    bcc?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof EmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    to: Array<string>;
}
/**
 * Options for forwarding an email
 * @export
 * @interface ForwardEmailOptions
 */
export interface ForwardEmailOptions {
    /**
     *
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    to: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    cc?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    bcc?: Array<string>;
}
/**
 * Representation of an inbox with an email address. Emails can be sent to or from this email address.
 * @export
 * @interface Inbox
 */
export interface Inbox {
    /**
     *
     * @type {Date}
     * @memberof Inbox
     */
    created?: Date;
    /**
     * The inbox's email address. Send an email to this address and the inbox will receive it
     * @type {string}
     * @memberof Inbox
     */
    emailAddress?: string;
    /**
     *
     * @type {string}
     * @memberof Inbox
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Inbox
     */
    userId?: string;
}
/**
 *
 * @export
 * @interface InboxProjection
 */
export interface InboxProjection {
    /**
     *
     * @type {Date}
     * @memberof InboxProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    id: string;
}
/**
 *
 * @export
 * @interface MatchOption
 */
export interface MatchOption {
    /**
     * The email property to match on. One of SUBJECT, TO, BCC, CC or FROM
     * @type {string}
     * @memberof MatchOption
     */
    field?: MatchOption.FieldEnum;
    /**
     * What criteria to apply. CONTAIN or EQUAL. Note CONTAIN is recommended due to some SMTP servers adding new lines
     * @type {string}
     * @memberof MatchOption
     */
    should?: MatchOption.ShouldEnum;
    /**
     * The value to compare to the field using EQUAL or CONTAIN
     * @type {string}
     * @memberof MatchOption
     */
    value?: string;
}
/**
 * @export
 * @namespace MatchOption
 */
export declare namespace MatchOption {
    /**
     * @export
     * @enum {string}
     */
    enum FieldEnum {
        SUBJECT = "SUBJECT",
        TO = "TO",
        BCC = "BCC",
        CC = "CC",
        FROM = "FROM"
    }
    /**
     * @export
     * @enum {string}
     */
    enum ShouldEnum {
        CONTAIN = "CONTAIN",
        EQUAL = "EQUAL"
    }
}
/**
 * Optional filter for matching emails based on fields
 * @export
 * @interface MatchOptions
 */
export interface MatchOptions {
    /**
     * 1 or more match options. Options are additive so if one does not match the email is excluded from results
     * @type {Array<MatchOption>}
     * @memberof MatchOptions
     */
    matches?: Array<MatchOption>;
}
/**
 *
 * @export
 * @interface PageEmailProjection
 */
export interface PageEmailProjection {
    /**
     *
     * @type {Array<EmailProjection>}
     * @memberof PageEmailProjection
     */
    content?: Array<EmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageInboxProjection
 */
export interface PageInboxProjection {
    /**
     *
     * @type {Array<InboxProjection>}
     * @memberof PageInboxProjection
     */
    content?: Array<InboxProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageInboxProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageInboxProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     *
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * Options for sending an email message from an inbox
 * @export
 * @interface SendEmailOptions
 */
export interface SendEmailOptions {
    /**
     * Optional list of attachment IDs to send with this email. You must first upload each attachment separately in order to obtain attachment IDs
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Optional list of bcc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Contents of email. If HTML set isHTML to true. You can use moustache templates here if you provide a templateVariables option
     * @type {string}
     * @memberof SendEmailOptions
     */
    body?: string;
    /**
     * Optional list of cc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional charset
     * @type {string}
     * @memberof SendEmailOptions
     */
    charset?: string;
    /**
     * Optional from address. If not set source inbox address will be used
     * @type {string}
     * @memberof SendEmailOptions
     */
    from?: string;
    /**
     *
     * @type {boolean}
     * @memberof SendEmailOptions
     */
    html?: boolean;
    /**
     * Optional replyTo header
     * @type {string}
     * @memberof SendEmailOptions
     */
    replyTo?: string;
    /**
     * Optional email subject line
     * @type {string}
     * @memberof SendEmailOptions
     */
    subject?: string;
    /**
     * Optional map of template variables. Will replace moustache syntax variables in subject or body with the associated values
     * @type {any}
     * @memberof SendEmailOptions
     */
    templateVariables?: any;
    /**
     * List of destination email addresses. Even single recipients must be in array form.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    to: Array<string>;
}
/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}
/**
 * Options for uploading files for attachments
 * @export
 * @interface UploadAttachmentOptions
 */
export interface UploadAttachmentOptions {
    /**
     * Base64 encoded string of file contents
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    base64Contents?: string;
    /**
     * Optional contentType for file. For instance application/pdf
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    contentType?: string;
    /**
     * Optional filename to save upload with
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    filename?: string;
}
/**
 * Representation of a webhook for an inbox.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Does Webhook expect basic authentication
     * @type {boolean}
     * @memberof Webhook
     */
    basicAuth?: boolean;
    /**
     *
     * @type {Date}
     * @memberof Webhook
     */
    createdAt: Date;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof Webhook
     */
    id?: string;
    /**
     * The inbox that the Webhook will be triggered by
     * @type {string}
     * @memberof Webhook
     */
    inboxId?: string;
    /**
     *
     * @type {string}
     * @memberof Webhook
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof Webhook
     */
    updatedAt: Date;
}
/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
export declare const AttachmentControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any): FetchArgs;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any): FetchArgs;
};
/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
export declare const AttachmentControllerApiFp: (configuration?: Configuration) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string[]>;
};
/**
 * AttachmentControllerApi - factory interface
 * @export
 */
export declare const AttachmentControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any): Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any): Promise<string[]>;
};
/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
export declare class AttachmentControllerApi extends BaseAPI {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any): Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any): Promise<string[]>;
}
/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
export declare const BulkActionsControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): FetchArgs;
    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(requestBody: string[], options?: any): FetchArgs;
    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): FetchArgs;
};
/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
export declare const BulkActionsControllerApiFp: (configuration?: Configuration) => {
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox[]>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(requestBody: string[], options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
};
/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
export declare const BulkActionsControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): Promise<Inbox[]>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(requestBody: string[], options?: any): Promise<Response>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): Promise<Response>;
};
/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
export declare class BulkActionsControllerApi extends BaseAPI {
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkCreateInboxes(count: number, options?: any): Promise<Inbox[]>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkDeleteInboxes(requestBody: Array<string>, options?: any): Promise<Response>;
    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): Promise<Response>;
}
/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
export declare const CommonActionsControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): FetchArgs;
    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): FetchArgs;
    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailAddress(inboxId: string, options?: any): FetchArgs;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): FetchArgs;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): FetchArgs;
    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any): FetchArgs;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, options?: any): FetchArgs;
    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any): FetchArgs;
    /**
     *
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any): FetchArgs;
};
/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
export declare const CommonActionsControllerApiFp: (configuration?: Configuration) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailAddress(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     *
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
};
/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
export declare const CommonActionsControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): Promise<Inbox>;
    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): Promise<Response>;
    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailAddress(inboxId: string, options?: any): Promise<Response>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any): Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, options?: any): Promise<Email>;
    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any): Promise<EmailPreview[]>;
    /**
     *
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any): Promise<Email>;
};
/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
export declare class CommonActionsControllerApi extends BaseAPI {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    createNewEmailAddress(options?: any): Promise<Inbox>;
    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    deleteEmail(emailId: string, options?: any): Promise<Response>;
    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    deleteEmailAddress(inboxId: string, options?: any): Promise<Response>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    emptyInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any): Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, options?: any): Promise<Email>;
    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any): Promise<EmailPreview[]>;
    /**
     *
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any): Promise<Email>;
}
/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
export declare const DomainControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(createDomainOptions: CreateDomainOptions, options?: any): FetchArgs;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): FetchArgs;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): FetchArgs;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): FetchArgs;
};
/**
 * DomainControllerApi - functional programming interface
 * @export
 */
export declare const DomainControllerApiFp: (configuration?: Configuration) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(createDomainOptions: CreateDomainOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPreview[]>;
};
/**
 * DomainControllerApi - factory interface
 * @export
 */
export declare const DomainControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(createDomainOptions: CreateDomainOptions, options?: any): Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): Promise<DomainPreview[]>;
};
/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
export declare class DomainControllerApi extends BaseAPI {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    createDomain(createDomainOptions: CreateDomainOptions, options?: any): Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    deleteDomain(id: string, options?: any): Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    getDomain(id: string, options?: any): Promise<DomainPlusVerificationRecordsAndStatus>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    getDomains(options?: any): Promise<DomainPreview[]>;
}
/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
export declare const EmailControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail1(emailId: string, options?: any): FetchArgs;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): FetchArgs;
    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): FetchArgs;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): FetchArgs;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, options?: any): FetchArgs;
    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(page?: number, size?: number, options?: any): FetchArgs;
    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): FetchArgs;
};
/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export declare const EmailControllerApiFp: (configuration?: Configuration) => {
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail1(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentMetaData>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
};
/**
 * EmailControllerApi - factory interface
 * @export
 */
export declare const EmailControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail1(emailId: string, options?: any): Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): Promise<Response>;
    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): Promise<AttachmentMetaData>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, options?: any): Promise<Email>;
    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(page?: number, size?: number, options?: any): Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): Promise<string>;
};
/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export declare class EmailControllerApi extends BaseAPI {
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    deleteEmail1(emailId: string, options?: any): Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): Promise<Response>;
    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): Promise<AttachmentMetaData>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getEmail(emailId: string, options?: any): Promise<Email>;
    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getEmailsPaginated(page?: number, size?: number, options?: any): Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getRawEmailContents(emailId: string, options?: any): Promise<string>;
}
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export declare const InboxControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(emailAddress?: string, options?: any): FetchArgs;
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any): FetchArgs;
    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): FetchArgs;
    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(page?: number, size?: number, options?: any): FetchArgs;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any): FetchArgs;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): FetchArgs;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): FetchArgs;
    /**
     *
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): FetchArgs;
    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any): FetchArgs;
};
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export declare const InboxControllerApiFp: (configuration?: Configuration) => {
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(emailAddress?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Webhook>;
    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox[]>;
    /**
     *
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Webhook[]>;
    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
};
/**
 * InboxControllerApi - factory interface
 * @export
 */
export declare const InboxControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(emailAddress?: string, options?: any): Promise<Inbox>;
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any): Promise<Webhook>;
    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): Promise<Response>;
    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(page?: number, size?: number, options?: any): Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any): Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): Promise<Inbox>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): Promise<Inbox[]>;
    /**
     *
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): Promise<Webhook[]>;
    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
};
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export declare class InboxControllerApi extends BaseAPI {
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    createInbox(emailAddress?: string, options?: any): Promise<Inbox>;
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any): Promise<Webhook>;
    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    deleteInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): Promise<Response>;
    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getAllInboxes(page?: number, size?: number, options?: any): Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any): Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInbox(inboxId: string, options?: any): Promise<Inbox>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInboxes(options?: any): Promise<Inbox[]>;
    /**
     *
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getWebhooks(inboxId: string, options?: any): Promise<Webhook[]>;
    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
}
