"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * ## Introduction  [MailSlurp](https://www.mailslurp.com) is an Email API for developers and QA testers. It let's users: - create emails addresses on demand - receive emails and attachments in code - send templated HTML emails  ## About  This page contains the REST API documentation for MailSlurp. All requests require API Key authentication passed as an `x-api-key` header.  Create an account to [get your free API Key](https://app.mailslurp.com/sign-up/).  ## Resources - ðŸ”‘  [Get API Key](https://app.mailslurp.com/sign-up/)                    - ðŸŽ“ [Developer Portal](https://www.mailslurp.com/developers/)           - ðŸ“¦ [Library SDKs](https://www.mailslurp.com/developers/integrations/) - âœï¸ [Code Examples](https://github.com/mailslurp/examples) - âš ï¸ [Report an issue](https://drift.me/mailslurp)  ## Explore
 *
 * OpenAPI spec version: 6.5.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var portableFetch = require("portable-fetch");
var BASE_PATH = "https://api.mailslurp.com".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        _this.name = "RequiredError";
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace MatchOption
 */
var MatchOption;
(function (MatchOption) {
    /**
     * @export
     * @enum {string}
     */
    var FieldEnum;
    (function (FieldEnum) {
        FieldEnum["SUBJECT"] = "SUBJECT";
        FieldEnum["TO"] = "TO";
        FieldEnum["BCC"] = "BCC";
        FieldEnum["CC"] = "CC";
        FieldEnum["FROM"] = "FROM";
    })(FieldEnum = MatchOption.FieldEnum || (MatchOption.FieldEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var ShouldEnum;
    (function (ShouldEnum) {
        ShouldEnum["CONTAIN"] = "CONTAIN";
        ShouldEnum["EQUAL"] = "EQUAL";
    })(ShouldEnum = MatchOption.ShouldEnum || (MatchOption.ShouldEnum = {}));
})(MatchOption = exports.MatchOption || (exports.MatchOption = {}));
/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
exports.AttachmentControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadAttachmentOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'uploadAttachmentOptions' is not null or undefined
            if (uploadAttachmentOptions === null || uploadAttachmentOptions === undefined) {
                throw new RequiredError('uploadAttachmentOptions', 'Required parameter uploadAttachmentOptions was null or undefined when calling uploadAttachment.');
            }
            var localVarPath = "/attachments";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("UploadAttachmentOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(uploadAttachmentOptions || {}) : (uploadAttachmentOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, filename, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadMultipartForm.');
            }
            var localVarPath = "/attachments/multipart";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }
            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
exports.AttachmentControllerApiFp = function (configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadAttachmentOptions, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadAttachment(uploadAttachmentOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, filename, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadMultipartForm(file, contentType, filename, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AttachmentControllerApi - factory interface
 * @export
 */
exports.AttachmentControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadAttachmentOptions, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadAttachment(uploadAttachmentOptions, options)(fetch, basePath);
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, filename, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadMultipartForm(file, contentType, filename, options)(fetch, basePath);
        },
    };
};
/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
var AttachmentControllerApi = /** @class */ (function (_super) {
    __extends(AttachmentControllerApi, _super);
    function AttachmentControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadAttachment = function (uploadAttachmentOptions, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadAttachment(uploadAttachmentOptions, options)(this.fetch, this.basePath);
    };
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadMultipartForm = function (file, contentType, filename, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadMultipartForm(file, contentType, filename, options)(this.fetch, this.basePath);
    };
    return AttachmentControllerApi;
}(BaseAPI));
exports.AttachmentControllerApi = AttachmentControllerApi;
/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
exports.BulkActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError('count', 'Required parameter count was null or undefined when calling bulkCreateInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (requestBody, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody', 'Required parameter requestBody was null or undefined when calling bulkDeleteInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (bulkSendEmailOptions === null || bulkSendEmailOptions === undefined) {
                throw new RequiredError('bulkSendEmailOptions', 'Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.');
            }
            var localVarPath = "/bulk/send";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("BulkSendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(bulkSendEmailOptions || {}) : (bulkSendEmailOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
exports.BulkActionsControllerApiFp = function (configuration) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkCreateInboxes(count, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (requestBody, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkDeleteInboxes(requestBody, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkSendEmails(bulkSendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
exports.BulkActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkCreateInboxes(count, options)(fetch, basePath);
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (requestBody, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(requestBody, options)(fetch, basePath);
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkSendEmails(bulkSendEmailOptions, options)(fetch, basePath);
        },
    };
};
/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
var BulkActionsControllerApi = /** @class */ (function (_super) {
    __extends(BulkActionsControllerApi, _super);
    function BulkActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkCreateInboxes = function (count, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(count, options)(this.fetch, this.basePath);
    };
    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkDeleteInboxes = function (requestBody, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(requestBody, options)(this.fetch, this.basePath);
    };
    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkSendEmails = function (bulkSendEmailOptions, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkSendEmails(bulkSendEmailOptions, options)(this.fetch, this.basePath);
    };
    return BulkActionsControllerApi;
}(BaseAPI));
exports.BulkActionsControllerApi = BulkActionsControllerApi;
/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
exports.CommonActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/newEmailAddress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling deleteEmail.');
            }
            var localVarPath = "/deleteEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (emailId !== undefined) {
                localVarQueryParameter['emailId'] = emailId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteEmailAddress.');
            }
            var localVarPath = "/deleteEmailAddress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling emptyInbox.');
            }
            var localVarPath = "/emptyInbox";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'sendEmailOptions' is not null or undefined
            if (sendEmailOptions === null || sendEmailOptions === undefined) {
                throw new RequiredError('sendEmailOptions', 'Required parameter sendEmailOptions was null or undefined when calling sendEmailSimple.');
            }
            var localVarPath = "/sendEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(sendEmailOptions || {}) : (sendEmailOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForEmailCount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForLatestEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError('matchOptions', 'Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.');
            }
            var localVarPath = "/waitForMatchingEmails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("MatchOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(matchOptions || {}) : (matchOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForNthEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
exports.CommonActionsControllerApiFp = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).deleteEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress: function (inboxId, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).deleteEmailAddress(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).emptyInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (sendEmailOptions, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).sendEmailSimple(sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).waitForEmailCount(count, inboxId, timeout, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).waitForLatestEmail(inboxId, timeout, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).waitForNthEmail(inboxId, index, timeout, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
exports.CommonActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            return exports.CommonActionsControllerApiFp(configuration).createNewEmailAddress(options)(fetch, basePath);
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            return exports.CommonActionsControllerApiFp(configuration).deleteEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress: function (inboxId, options) {
            return exports.CommonActionsControllerApiFp(configuration).deleteEmailAddress(inboxId, options)(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            return exports.CommonActionsControllerApiFp(configuration).emptyInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (sendEmailOptions, options) {
            return exports.CommonActionsControllerApiFp(configuration).sendEmailSimple(sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, options) {
            return exports.CommonActionsControllerApiFp(configuration).waitForEmailCount(count, inboxId, timeout, options)(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, options) {
            return exports.CommonActionsControllerApiFp(configuration).waitForLatestEmail(inboxId, timeout, options)(fetch, basePath);
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, options) {
            return exports.CommonActionsControllerApiFp(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options)(fetch, basePath);
        },
        /**
         *
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, options) {
            return exports.CommonActionsControllerApiFp(configuration).waitForNthEmail(inboxId, index, timeout, options)(fetch, basePath);
        },
    };
};
/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
var CommonActionsControllerApi = /** @class */ (function (_super) {
    __extends(CommonActionsControllerApi, _super);
    function CommonActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.createNewEmailAddress = function (options) {
        return exports.CommonActionsControllerApiFp(this.configuration).createNewEmailAddress(options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.deleteEmail = function (emailId, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).deleteEmail(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.deleteEmailAddress = function (inboxId, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).deleteEmailAddress(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.emptyInbox = function (inboxId, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).emptyInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.sendEmailSimple = function (sendEmailOptions, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).sendEmailSimple(sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.waitForEmailCount = function (count, inboxId, timeout, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).waitForEmailCount(count, inboxId, timeout, options)(this.fetch, this.basePath);
    };
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.waitForLatestEmail = function (inboxId, timeout, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).waitForLatestEmail(inboxId, timeout, options)(this.fetch, this.basePath);
    };
    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.waitForMatchingEmail = function (matchOptions, count, inboxId, timeout, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.waitForNthEmail = function (inboxId, index, timeout, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).waitForNthEmail(inboxId, index, timeout, options)(this.fetch, this.basePath);
    };
    return CommonActionsControllerApi;
}(BaseAPI));
exports.CommonActionsControllerApi = CommonActionsControllerApi;
/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
exports.DomainControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (createDomainOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createDomainOptions' is not null or undefined
            if (createDomainOptions === null || createDomainOptions === undefined) {
                throw new RequiredError('createDomainOptions', 'Required parameter createDomainOptions was null or undefined when calling createDomain.');
            }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CreateDomainOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createDomainOptions || {}) : (createDomainOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteDomain.');
            }
            var localVarPath = "/domains/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getDomain.');
            }
            var localVarPath = "/domains/{id}"
                .replace("{" + "id" + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DomainControllerApi - functional programming interface
 * @export
 */
exports.DomainControllerApiFp = function (configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (createDomainOptions, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).createDomain(createDomainOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).deleteDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomains(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DomainControllerApi - factory interface
 * @export
 */
exports.DomainControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (createDomainOptions, options) {
            return exports.DomainControllerApiFp(configuration).createDomain(createDomainOptions, options)(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).deleteDomain(id, options)(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).getDomain(id, options)(fetch, basePath);
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            return exports.DomainControllerApiFp(configuration).getDomains(options)(fetch, basePath);
        },
    };
};
/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
var DomainControllerApi = /** @class */ (function (_super) {
    __extends(DomainControllerApi, _super);
    function DomainControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.createDomain = function (createDomainOptions, options) {
        return exports.DomainControllerApiFp(this.configuration).createDomain(createDomainOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.deleteDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).deleteDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).getDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomains = function (options) {
        return exports.DomainControllerApiFp(this.configuration).getDomains(options)(this.fetch, this.basePath);
    };
    return DomainControllerApi;
}(BaseAPI));
exports.DomainControllerApi = DomainControllerApi;
/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
exports.EmailControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling deleteEmail1.');
            }
            var localVarPath = "/emails/{emailId}"
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachment.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling downloadAttachment.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}"
                .replace("{" + "attachmentId" + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling forwardEmail.');
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (forwardEmailOptions === null || forwardEmailOptions === undefined) {
                throw new RequiredError('forwardEmailOptions', 'Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.');
            }
            var localVarPath = "/emails/{emailId}/forward"
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ForwardEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(forwardEmailOptions || {}) : (forwardEmailOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getAttachmentMetaData.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}/metadata"
                .replace("{" + "attachmentId" + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmail.');
            }
            var localVarPath = "/emails/{emailId}"
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (page, size, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getRawEmailContents.');
            }
            var localVarPath = "/emails/{emailId}/raw"
                .replace("{" + "emailId" + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EmailControllerApi - functional programming interface
 * @export
 */
exports.EmailControllerApiFp = function (configuration) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).deleteEmail1(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).downloadAttachment(attachmentId, emailId, apiKey, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).forwardEmail(emailId, forwardEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getAttachmentMetaData(attachmentId, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (page, size, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailsPaginated(page, size, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getRawEmailContents(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * EmailControllerApi - factory interface
 * @export
 */
exports.EmailControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).deleteEmail1(emailId, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            return exports.EmailControllerApiFp(configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(fetch, basePath);
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            return exports.EmailControllerApiFp(configuration).forwardEmail(emailId, forwardEmailOptions, options)(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            return exports.EmailControllerApiFp(configuration).getAttachmentMetaData(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (page, size, options) {
            return exports.EmailControllerApiFp(configuration).getEmailsPaginated(page, size, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getRawEmailContents(emailId, options)(fetch, basePath);
        },
    };
};
/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
var EmailControllerApi = /** @class */ (function (_super) {
    __extends(EmailControllerApi, _super);
    function EmailControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.deleteEmail1 = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).deleteEmail1(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.downloadAttachment = function (attachmentId, emailId, apiKey, options) {
        return exports.EmailControllerApiFp(this.configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(this.fetch, this.basePath);
    };
    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.forwardEmail = function (emailId, forwardEmailOptions, options) {
        return exports.EmailControllerApiFp(this.configuration).forwardEmail(emailId, forwardEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getAttachmentMetaData = function (attachmentId, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getAttachmentMetaData(attachmentId, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmail = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmail(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailsPaginated = function (page, size, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailsPaginated(page, size, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getRawEmailContents = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getRawEmailContents(emailId, options)(this.fetch, this.basePath);
    };
    return EmailControllerApi;
}(BaseAPI));
exports.EmailControllerApi = EmailControllerApi;
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
exports.InboxControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (emailAddress, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, createWebhookOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling createWebhook.');
            }
            // verify required parameter 'createWebhookOptions' is not null or undefined
            if (createWebhookOptions === null || createWebhookOptions === undefined) {
                throw new RequiredError('createWebhookOptions', 'Required parameter createWebhookOptions was null or undefined when calling createWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CreateWebhookOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createWebhookOptions || {}) : (createWebhookOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling deleteWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks/{webhookId}"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)))
                .replace("{" + "webhookId" + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (page, size, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getEmails.');
            }
            var localVarPath = "/inboxes/{inboxId}/emails"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }
            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getWebhooks.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling sendEmail.');
            }
            // verify required parameter 'sendEmailOptions' is not null or undefined
            if (sendEmailOptions === null || sendEmailOptions === undefined) {
                throw new RequiredError('sendEmailOptions', 'Required parameter sendEmailOptions was null or undefined when calling sendEmail.');
            }
            var localVarPath = "/inboxes/{inboxId}"
                .replace("{" + "inboxId" + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-api-key")
                    : configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(sendEmailOptions || {}) : (sendEmailOptions || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
exports.InboxControllerApiFp = function (configuration) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (emailAddress, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createInbox(emailAddress, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, createWebhookOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createWebhook(inboxId, createWebhookOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteWebhook(inboxId, webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (page, size, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getAllInboxes(page, size, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxes(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getWebhooks(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmail(inboxId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * InboxControllerApi - factory interface
 * @export
 */
exports.InboxControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (emailAddress, options) {
            return exports.InboxControllerApiFp(configuration).createInbox(emailAddress, options)(fetch, basePath);
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, createWebhookOptions, options) {
            return exports.InboxControllerApiFp(configuration).createWebhook(inboxId, createWebhookOptions, options)(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).deleteInbox(inboxId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            return exports.InboxControllerApiFp(configuration).deleteWebhook(inboxId, webhookId, options)(fetch, basePath);
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (page, size, options) {
            return exports.InboxControllerApiFp(configuration).getAllInboxes(page, size, options)(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, options) {
            return exports.InboxControllerApiFp(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).getInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            return exports.InboxControllerApiFp(configuration).getInboxes(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).getWebhooks(inboxId, options)(fetch, basePath);
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            return exports.InboxControllerApiFp(configuration).sendEmail(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
    };
};
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
var InboxControllerApi = /** @class */ (function (_super) {
    __extends(InboxControllerApi, _super);
    function InboxControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createInbox = function (emailAddress, options) {
        return exports.InboxControllerApiFp(this.configuration).createInbox(emailAddress, options)(this.fetch, this.basePath);
    };
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createWebhook = function (inboxId, createWebhookOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).createWebhook(inboxId, createWebhookOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).deleteInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteWebhook = function (inboxId, webhookId, options) {
        return exports.InboxControllerApiFp(this.configuration).deleteWebhook(inboxId, webhookId, options)(this.fetch, this.basePath);
    };
    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getAllInboxes = function (page, size, options) {
        return exports.InboxControllerApiFp(this.configuration).getAllInboxes(page, size, options)(this.fetch, this.basePath);
    };
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getEmails = function (inboxId, limit, minCount, retryTimeout, since, options) {
        return exports.InboxControllerApiFp(this.configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).getInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxes = function (options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxes(options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getWebhooks = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).getWebhooks(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmail = function (inboxId, sendEmailOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmail(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    return InboxControllerApi;
}(BaseAPI));
exports.InboxControllerApi = InboxControllerApi;
