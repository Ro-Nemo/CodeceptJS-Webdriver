/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * ## Introduction  [MailSlurp](https://www.mailslurp.com) is an Email API for developers and QA testers. It let's users: - create emails addresses on demand - receive emails and attachments in code - send templated HTML emails  ## About  This page contains the REST API documentation for MailSlurp. All requests require API Key authentication passed as an `x-api-key` header.  Create an account to [get your free API Key](https://app.mailslurp.com/sign-up/).  ## Resources - üîë  [Get API Key](https://app.mailslurp.com/sign-up/)                    - üéì [Developer Portal](https://www.mailslurp.com/developers/)           - üì¶ [Library SDKs](https://www.mailslurp.com/developers/integrations/) - ‚úçÔ∏è [Code Examples](https://github.com/mailslurp/examples) - ‚ö†Ô∏è [Report an issue](https://drift.me/mailslurp)  ## Explore  
 *
 * OpenAPI spec version: 6.5.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.mailslurp.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AttachmentMetaData
 */
export interface AttachmentMetaData {
    /**
     * 
     * @type {number}
     * @memberof AttachmentMetaData
     */
    contentLength: number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentMetaData
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentMetaData
     */
    name: string;
}

/**
 * 
 * @export
 * @interface BasicAuthOptions
 */
export interface BasicAuthOptions {
    /**
     * 
     * @type {string}
     * @memberof BasicAuthOptions
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BasicAuthOptions
     */
    password: string;
}

/**
 * Bulk sending options
 * @export
 * @interface BulkSendEmailOptions
 */
export interface BulkSendEmailOptions {
    /**
     * Inboxes to send from
     * @type {Array<string>}
     * @memberof BulkSendEmailOptions
     */
    inboxIds?: Array<string>;
    /**
     * 
     * @type {SendEmailOptions}
     * @memberof BulkSendEmailOptions
     */
    sendEmailOptions: SendEmailOptions;
}

/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it.
 * @export
 * @interface CreateDomainOptions
 */
export interface CreateDomainOptions {
    /**
     * The top level domain you wish to use with MailSlurp
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domain?: string;
}

/**
 * 
 * @export
 * @interface CreateWebhookOptions
 */
export interface CreateWebhookOptions {
    /**
     * 
     * @type {BasicAuthOptions}
     * @memberof CreateWebhookOptions
     */
    basicAuth?: BasicAuthOptions;
    /**
     * Public URL (including protocol) that MailSlurp can post WebhookNotificationObjects to when an email is received
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface DomainPlusVerificationRecordsAndStatus
 */
export interface DomainPlusVerificationRecordsAndStatus {
    /**
     * 
     * @type {Date}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    domain: string;
    /**
     * 
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    id: string;
    /**
     * 
     * @type {Date}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    updatedAt: Date;
    /**
     * 
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    verificationToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof DomainPlusVerificationRecordsAndStatus
     */
    verified: boolean;
}

/**
 * Preview object for domain entity
 * @export
 * @interface DomainPreview
 */
export interface DomainPreview {
    /**
     * 
     * @type {Date}
     * @memberof DomainPreview
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof DomainPreview
     */
    domain: string;
    /**
     * 
     * @type {string}
     * @memberof DomainPreview
     */
    id: string;
}

/**
 * Representation of an email
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {EmailAnalysis}
     * @memberof Email
     */
    analysis?: EmailAnalysis;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    attachments?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    bcc?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    body?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    cc?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    charset?: string;
    /**
     * 
     * @type {Date}
     * @memberof Email
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    from?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    headers?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof Email
     */
    html?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    inboxId: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    rawUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    subject?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    to: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof Email
     */
    updatedAt: Date;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    userId: string;
}

/**
 * Analysis of email
 * @export
 * @interface EmailAnalysis
 */
export interface EmailAnalysis {
    /**
     * 
     * @type {string}
     * @memberof EmailAnalysis
     */
    dkimVerdict?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAnalysis
     */
    dmarcVerdict?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAnalysis
     */
    spamVerdict?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAnalysis
     */
    spfVerdict?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAnalysis
     */
    virusVerdict?: string;
}

/**
 * Preview of an email message. For full message call the email endpoints with the provided email id.
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    bcc?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    cc?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof EmailPreview
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof EmailPreview
     */
    createdAt: Date;
    /**
     * ID of the Email.
     * @type {string}
     * @memberof EmailPreview
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    to: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailProjection
 */
export interface EmailProjection {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    attachments: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    bcc?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    cc?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof EmailProjection
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof EmailProjection
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProjection
     */
    inboxId: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProjection
     */
    subject?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    to: Array<string>;
}

/**
 * Options for forwarding an email
 * @export
 * @interface ForwardEmailOptions
 */
export interface ForwardEmailOptions {
    /**
     * 
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    to: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    subject?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    cc?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    bcc?: Array<string>;
}

/**
 * Representation of an inbox with an email address. Emails can be sent to or from this email address.
 * @export
 * @interface Inbox
 */
export interface Inbox {
    /**
     * 
     * @type {Date}
     * @memberof Inbox
     */
    created?: Date;
    /**
     * The inbox's email address. Send an email to this address and the inbox will receive it
     * @type {string}
     * @memberof Inbox
     */
    emailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Inbox
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Inbox
     */
    userId?: string;
}

/**
 * 
 * @export
 * @interface InboxProjection
 */
export interface InboxProjection {
    /**
     * 
     * @type {Date}
     * @memberof InboxProjection
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof InboxProjection
     */
    id: string;
}

/**
 * 
 * @export
 * @interface MatchOption
 */
export interface MatchOption {
    /**
     * The email property to match on. One of SUBJECT, TO, BCC, CC or FROM
     * @type {string}
     * @memberof MatchOption
     */
    field?: MatchOption.FieldEnum;
    /**
     * What criteria to apply. CONTAIN or EQUAL. Note CONTAIN is recommended due to some SMTP servers adding new lines
     * @type {string}
     * @memberof MatchOption
     */
    should?: MatchOption.ShouldEnum;
    /**
     * The value to compare to the field using EQUAL or CONTAIN
     * @type {string}
     * @memberof MatchOption
     */
    value?: string;
}

/**
 * @export
 * @namespace MatchOption
 */
export namespace MatchOption {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        SUBJECT = 'SUBJECT',
        TO = 'TO',
        BCC = 'BCC',
        CC = 'CC',
        FROM = 'FROM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ShouldEnum {
        CONTAIN = 'CONTAIN',
        EQUAL = 'EQUAL'
    }
}

/**
 * Optional filter for matching emails based on fields
 * @export
 * @interface MatchOptions
 */
export interface MatchOptions {
    /**
     * 1 or more match options. Options are additive so if one does not match the email is excluded from results
     * @type {Array<MatchOption>}
     * @memberof MatchOptions
     */
    matches?: Array<MatchOption>;
}

/**
 * 
 * @export
 * @interface PageEmailProjection
 */
export interface PageEmailProjection {
    /**
     * 
     * @type {Array<EmailProjection>}
     * @memberof PageEmailProjection
     */
    content?: Array<EmailProjection>;
    /**
     * 
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageEmailProjection
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageEmailProjection
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageEmailProjection
     */
    pageable?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageEmailProjection
     */
    size?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageEmailProjection
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface PageInboxProjection
 */
export interface PageInboxProjection {
    /**
     * 
     * @type {Array<InboxProjection>}
     * @memberof PageInboxProjection
     */
    content?: Array<InboxProjection>;
    /**
     * 
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageInboxProjection
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInboxProjection
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageInboxProjection
     */
    pageable?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageInboxProjection
     */
    size?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageInboxProjection
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}

/**
 * Options for sending an email message from an inbox
 * @export
 * @interface SendEmailOptions
 */
export interface SendEmailOptions {
    /**
     * Optional list of attachment IDs to send with this email. You must first upload each attachment separately in order to obtain attachment IDs
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Optional list of bcc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Contents of email. If HTML set isHTML to true. You can use moustache templates here if you provide a templateVariables option
     * @type {string}
     * @memberof SendEmailOptions
     */
    body?: string;
    /**
     * Optional list of cc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional charset
     * @type {string}
     * @memberof SendEmailOptions
     */
    charset?: string;
    /**
     * Optional from address. If not set source inbox address will be used
     * @type {string}
     * @memberof SendEmailOptions
     */
    from?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SendEmailOptions
     */
    html?: boolean;
    /**
     * Optional replyTo header
     * @type {string}
     * @memberof SendEmailOptions
     */
    replyTo?: string;
    /**
     * Optional email subject line
     * @type {string}
     * @memberof SendEmailOptions
     */
    subject?: string;
    /**
     * Optional map of template variables. Will replace moustache syntax variables in subject or body with the associated values
     * @type {any}
     * @memberof SendEmailOptions
     */
    templateVariables?: any;
    /**
     * List of destination email addresses. Even single recipients must be in array form.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    to: Array<string>;
}

/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}

/**
 * Options for uploading files for attachments
 * @export
 * @interface UploadAttachmentOptions
 */
export interface UploadAttachmentOptions {
    /**
     * Base64 encoded string of file contents
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    base64Contents?: string;
    /**
     * Optional contentType for file. For instance application/pdf
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    contentType?: string;
    /**
     * Optional filename to save upload with
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    filename?: string;
}

/**
 * Representation of a webhook for an inbox.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Does Webhook expect basic authentication
     * @type {boolean}
     * @memberof Webhook
     */
    basicAuth?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Webhook
     */
    createdAt: Date;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof Webhook
     */
    id?: string;
    /**
     * The inbox that the Webhook will be triggered by
     * @type {string}
     * @memberof Webhook
     */
    inboxId?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof Webhook
     */
    updatedAt: Date;
}


/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
export const AttachmentControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options: any = {}): FetchArgs {
            // verify required parameter 'uploadAttachmentOptions' is not null or undefined
            if (uploadAttachmentOptions === null || uploadAttachmentOptions === undefined) {
                throw new RequiredError('uploadAttachmentOptions','Required parameter uploadAttachmentOptions was null or undefined when calling uploadAttachment.');
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UploadAttachmentOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(uploadAttachmentOptions || {}) : (uploadAttachmentOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(file: any, contentType?: string, filename?: string, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadMultipartForm.');
            }
            const localVarPath = `/attachments/multipart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
export const AttachmentControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(configuration).uploadAttachment(uploadAttachmentOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(configuration).uploadMultipartForm(file, contentType, filename, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttachmentControllerApi - factory interface
 * @export
 */
export const AttachmentControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending
         * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any) {
            return AttachmentControllerApiFp(configuration).uploadAttachment(uploadAttachmentOptions, options)(fetch, basePath);
        },
        /**
         * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
         * @summary Upload an attachment for sending using Multipart Form
         * @param {any} file file
         * @param {string} [contentType] contentType
         * @param {string} [filename] filename
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any) {
            return AttachmentControllerApiFp(configuration).uploadMultipartForm(file, contentType, filename, options)(fetch, basePath);
        },
    };
};

/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
export class AttachmentControllerApi extends BaseAPI {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadAttachmentOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadAttachment(uploadAttachmentOptions: UploadAttachmentOptions, options?: any) {
        return AttachmentControllerApiFp(this.configuration).uploadAttachment(uploadAttachmentOptions, options)(this.fetch, this.basePath);
    }

    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [filename] filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadMultipartForm(file: any, contentType?: string, filename?: string, options?: any) {
        return AttachmentControllerApiFp(this.configuration).uploadMultipartForm(file, contentType, filename, options)(this.fetch, this.basePath);
    }

}

/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
export const BulkActionsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options: any = {}): FetchArgs {
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError('count','Required parameter count was null or undefined when calling bulkCreateInboxes.');
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(requestBody: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling bulkDeleteInboxes.');
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options: any = {}): FetchArgs {
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (bulkSendEmailOptions === null || bulkSendEmailOptions === undefined) {
                throw new RequiredError('bulkSendEmailOptions','Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.');
            }
            const localVarPath = `/bulk/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkSendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bulkSendEmailOptions || {}) : (bulkSendEmailOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
export const BulkActionsControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(configuration).bulkCreateInboxes(count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(requestBody: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(configuration).bulkDeleteInboxes(requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(configuration).bulkSendEmails(bulkSendEmailOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
export const BulkActionsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Enterprise Plan Required
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkCreateInboxes(count, options)(fetch, basePath);
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} requestBody ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(requestBody: Array<string>, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(requestBody, options)(fetch, basePath);
        },
        /**
         * Enterprise Plan Required
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkSendEmails(bulkSendEmailOptions, options)(fetch, basePath);
        },
    };
};

/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
export class BulkActionsControllerApi extends BaseAPI {
    /**
     * Enterprise Plan Required
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkCreateInboxes(count: number, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(count, options)(this.fetch, this.basePath);
    }

    /**
     * Enterprise Plan Required
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} requestBody ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkDeleteInboxes(requestBody: Array<string>, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * Enterprise Plan Required
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkSendEmails(bulkSendEmailOptions, options)(this.fetch, this.basePath);
    }

}

/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
export const CommonActionsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(options: any = {}): FetchArgs {
            const localVarPath = `/newEmailAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling deleteEmail.');
            }
            const localVarPath = `/deleteEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (emailId !== undefined) {
                localVarQueryParameter['emailId'] = emailId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling deleteEmailAddress.');
            }
            const localVarPath = `/deleteEmailAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling emptyInbox.');
            }
            const localVarPath = `/emptyInbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(sendEmailOptions: SendEmailOptions, options: any = {}): FetchArgs {
            // verify required parameter 'sendEmailOptions' is not null or undefined
            if (sendEmailOptions === null || sendEmailOptions === undefined) {
                throw new RequiredError('sendEmailOptions','Required parameter sendEmailOptions was null or undefined when calling sendEmailSimple.');
            }
            const localVarPath = `/sendEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendEmailOptions || {}) : (sendEmailOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails 
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options: any = {}): FetchArgs {
            const localVarPath = `/waitForEmailCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(inboxId?: string, timeout?: number, options: any = {}): FetchArgs {
            const localVarPath = `/waitForLatestEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options: any = {}): FetchArgs {
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError('matchOptions','Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.');
            }
            const localVarPath = `/waitForMatchingEmails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MatchOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(matchOptions || {}) : (matchOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options: any = {}): FetchArgs {
            const localVarPath = `/waitForNthEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
export const CommonActionsControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).deleteEmail(emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).deleteEmailAddress(inboxId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).emptyInbox(inboxId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).sendEmailSimple(sendEmailOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails 
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).waitForEmailCount(count, inboxId, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).waitForLatestEmail(inboxId, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(configuration).waitForNthEmail(inboxId, index, timeout, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
export const CommonActionsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(options?: any) {
            return CommonActionsControllerApiFp(configuration).createNewEmailAddress(options)(fetch, basePath);
        },
        /**
         * Deletes an email
         * @summary Delete an email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options?: any) {
            return CommonActionsControllerApiFp(configuration).deleteEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Deletes an inbox
         * @summary Delete email address and its emails
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailAddress(inboxId: string, options?: any) {
            return CommonActionsControllerApiFp(configuration).deleteEmailAddress(inboxId, options)(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options?: any) {
            return CommonActionsControllerApiFp(configuration).emptyInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * To specify an email address first create an inbox and use that with the other send email methods
         * @summary Send an email from a random email address
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any) {
            return CommonActionsControllerApiFp(configuration).sendEmailSimple(sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Wait for and return count number of emails 
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any) {
            return CommonActionsControllerApiFp(configuration).waitForEmailCount(count, inboxId, timeout, options)(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
         * @summary Fetch inbox's latest email or if empty wait for email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(inboxId?: string, timeout?: number, options?: any) {
            return CommonActionsControllerApiFp(configuration).waitForLatestEmail(inboxId, timeout, options)(fetch, basePath);
        },
        /**
         * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any) {
            return CommonActionsControllerApiFp(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any) {
            return CommonActionsControllerApiFp(configuration).waitForNthEmail(inboxId, index, timeout, options)(fetch, basePath);
        },
    };
};

/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
export class CommonActionsControllerApi extends BaseAPI {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public createNewEmailAddress(options?: any) {
        return CommonActionsControllerApiFp(this.configuration).createNewEmailAddress(options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an email
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public deleteEmail(emailId: string, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).deleteEmail(emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes an inbox
     * @summary Delete email address and its emails
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public deleteEmailAddress(inboxId: string, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).deleteEmailAddress(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public emptyInbox(inboxId: string, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).emptyInbox(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).sendEmailSimple(sendEmailOptions, options)(this.fetch, this.basePath);
    }

    /**
     * Will only wait if count is greater that the found emails in given inbox.If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Wait for and return count number of emails 
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public waitForEmailCount(count?: number, inboxId?: string, timeout?: number, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).waitForEmailCount(count, inboxId, timeout, options)(this.fetch, this.basePath);
    }

    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods.
     * @summary Fetch inbox's latest email or if empty wait for email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public waitForLatestEmail(inboxId?: string, timeout?: number, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).waitForLatestEmail(inboxId, timeout, options)(this.fetch, this.basePath);
    }

    /**
     * Results must also meet provided count. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public waitForNthEmail(inboxId?: string, index?: number, timeout?: number, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).waitForNthEmail(inboxId, index, timeout, options)(this.fetch, this.basePath);
    }

}

/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
export const DomainControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(createDomainOptions: CreateDomainOptions, options: any = {}): FetchArgs {
            // verify required parameter 'createDomainOptions' is not null or undefined
            if (createDomainOptions === null || createDomainOptions === undefined) {
                throw new RequiredError('createDomainOptions','Required parameter createDomainOptions was null or undefined when calling createDomain.');
            }
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDomainOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createDomainOptions || {}) : (createDomainOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDomain.');
            }
            const localVarPath = `/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDomain.');
            }
            const localVarPath = `/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options: any = {}): FetchArgs {
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainControllerApi - functional programming interface
 * @export
 */
export const DomainControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(createDomainOptions: CreateDomainOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPlusVerificationRecordsAndStatus> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(configuration).createDomain(createDomainOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(configuration).deleteDomain(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPlusVerificationRecordsAndStatus> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(configuration).getDomain(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DomainPreview>> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(configuration).getDomains(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DomainControllerApi - factory interface
 * @export
 */
export const DomainControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} createDomainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(createDomainOptions: CreateDomainOptions, options?: any) {
            return DomainControllerApiFp(configuration).createDomain(createDomainOptions, options)(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).deleteDomain(id, options)(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).getDomain(id, options)(fetch, basePath);
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options?: any) {
            return DomainControllerApiFp(configuration).getDomains(options)(fetch, basePath);
        },
    };
};

/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
export class DomainControllerApi extends BaseAPI {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} createDomainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public createDomain(createDomainOptions: CreateDomainOptions, options?: any) {
        return DomainControllerApiFp(this.configuration).createDomain(createDomainOptions, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public deleteDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).deleteDomain(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).getDomain(id, options)(this.fetch, this.basePath);
    }

    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomains(options?: any) {
        return DomainControllerApiFp(this.configuration).getDomains(options)(this.fetch, this.basePath);
    }

}

/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
export const EmailControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling deleteEmail1.');
            }
            const localVarPath = `/emails/{emailId}`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling downloadAttachment.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling downloadAttachment.');
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling forwardEmail.');
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (forwardEmailOptions === null || forwardEmailOptions === undefined) {
                throw new RequiredError('forwardEmailOptions','Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.');
            }
            const localVarPath = `/emails/{emailId}/forward`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ForwardEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(forwardEmailOptions || {}) : (forwardEmailOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(attachmentId: string, emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getAttachmentMetaData.');
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}/metadata`
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getEmail.');
            }
            const localVarPath = `/emails/{emailId}`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(page?: number, size?: number, options: any = {}): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getRawEmailContents.');
            }
            const localVarPath = `/emails/{emailId}/raw`
                .replace(`{${"emailId"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export const EmailControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).deleteEmail1(emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).downloadAttachment(attachmentId, emailId, apiKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).forwardEmail(emailId, forwardEmailOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentMetaData> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).getAttachmentMetaData(attachmentId, emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).getEmail(emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailProjection> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).getEmailsPaginated(page, size, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(configuration).getRawEmailContents(emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailControllerApi - factory interface
 * @export
 */
export const EmailControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes an email and removes it from the inbox
         * @summary Delete Email
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail1(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).deleteEmail1(emailId, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
         * @summary Get email attachment
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any) {
            return EmailControllerApiFp(configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(fetch, basePath);
        },
        /**
         * Forward email content to given recipients
         * @summary Forward Email
         * @param {string} emailId emailId
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any) {
            return EmailControllerApiFp(configuration).forwardEmail(emailId, forwardEmailOptions, options)(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId attachmentId
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(attachmentId: string, emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getAttachmentMetaData(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
         * @summary Get Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Responses are paginated
         * @summary Get all emails
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(page?: number, size?: number, options?: any) {
            return EmailControllerApiFp(configuration).getEmailsPaginated(page, size, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed and unprocessed email
         * @summary Get Raw Email Content
         * @param {string} emailId emailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getRawEmailContents(emailId, options)(fetch, basePath);
        },
    };
};

/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export class EmailControllerApi extends BaseAPI {
    /**
     * Deletes an email and removes it from the inbox
     * @summary Delete Email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public deleteEmail1(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).deleteEmail1(emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a byte stream (file download). Get the attachmentId from the email response.
     * @summary Get email attachment
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any) {
        return EmailControllerApiFp(this.configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(this.fetch, this.basePath);
    }

    /**
     * Forward email content to given recipients
     * @summary Forward Email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any) {
        return EmailControllerApiFp(this.configuration).forwardEmail(emailId, forwardEmailOptions, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getAttachmentMetaData(attachmentId: string, emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getAttachmentMetaData(attachmentId, emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawMessage endpoint
     * @summary Get Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmail(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmail(emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Responses are paginated
     * @summary Get all emails
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailsPaginated(page?: number, size?: number, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmailsPaginated(page, size, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a raw, unparsed and unprocessed email
     * @summary Get Raw Email Content
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getRawEmailContents(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getRawEmailContents(emailId, options)(this.fetch, this.basePath);
    }

}

/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export const InboxControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(emailAddress?: string, options: any = {}): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling createWebhook.');
            }
            // verify required parameter 'createWebhookOptions' is not null or undefined
            if (createWebhookOptions === null || createWebhookOptions === undefined) {
                throw new RequiredError('createWebhookOptions','Required parameter createWebhookOptions was null or undefined when calling createWebhook.');
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWebhookOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createWebhookOptions || {}) : (createWebhookOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling deleteInbox.');
            }
            const localVarPath = `/inboxes/{inboxId}`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(inboxId: string, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling deleteWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks/{webhookId}`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(page?: number, size?: number, options: any = {}): FetchArgs {
            const localVarPath = `/inboxes/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling getEmails.');
            }
            const localVarPath = `/inboxes/{inboxId}/emails`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }

            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling getInbox.');
            }
            const localVarPath = `/inboxes/{inboxId}`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId','Required parameter inboxId was null or undefined when calling sendEmail.');
            }
            // verify required parameter 'sendEmailOptions' is not null or undefined
            if (sendEmailOptions === null || sendEmailOptions === undefined) {
                throw new RequiredError('sendEmailOptions','Required parameter sendEmailOptions was null or undefined when calling sendEmail.');
            }
            const localVarPath = `/inboxes/{inboxId}`
                .replace(`{${"inboxId"}}`, encodeURIComponent(String(inboxId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendEmailOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sendEmailOptions || {}) : (sendEmailOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export const InboxControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(emailAddress?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).createInbox(emailAddress, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Webhook> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).createWebhook(inboxId, createWebhookOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).deleteInbox(inboxId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(inboxId: string, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).deleteWebhook(inboxId, webhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageInboxProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getAllInboxes(page, size, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getInbox(inboxId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getInboxes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Webhook>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).getWebhooks(inboxId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(configuration).sendEmail(inboxId, sendEmailOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InboxControllerApi - factory interface
 * @export
 */
export const InboxControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
         * @summary Create an Inbox (email address)
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(emailAddress?: string, options?: any) {
            return InboxControllerApiFp(configuration).createInbox(emailAddress, options)(fetch, basePath);
        },
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any) {
            return InboxControllerApiFp(configuration).createWebhook(inboxId, createWebhookOptions, options)(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address
         * @summary Delete Inbox / Email Address
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).deleteInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete and disable a WebHook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(inboxId: string, webhookId: string, options?: any) {
            return InboxControllerApiFp(configuration).deleteWebhook(inboxId, webhookId, options)(fetch, basePath);
        },
        /**
         * List inboxes in paginated form
         * @summary List Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(page?: number, size?: number, options?: any) {
            return InboxControllerApiFp(configuration).getAllInboxes(page, size, options)(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary List Emails in an Inbox / EmailAddress
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by descending received date time
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any) {
            return InboxControllerApiFp(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox / EmailAddress
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).getInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(options?: any) {
            return InboxControllerApiFp(configuration).getInboxes(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all WebHooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).getWebhooks(inboxId, options)(fetch, basePath);
        },
        /**
         * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
         * @summary Send Email
         * @param {string} inboxId inboxId
         * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any) {
            return InboxControllerApiFp(configuration).sendEmail(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
    };
};

/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export class InboxControllerApi extends BaseAPI {
    /**
     * Create a new inbox and with a ranmdomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. 
     * @summary Create an Inbox (email address)
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createInbox(emailAddress?: string, options?: any) {
        return InboxControllerApiFp(this.configuration).createInbox(emailAddress, options)(this.fetch, this.basePath);
    }

    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} createWebhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createWebhook(inboxId: string, createWebhookOptions: CreateWebhookOptions, options?: any) {
        return InboxControllerApiFp(this.configuration).createWebhook(inboxId, createWebhookOptions, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete an inbox and associated email address
     * @summary Delete Inbox / Email Address
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).deleteInbox(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete and disable a WebHook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteWebhook(inboxId: string, webhookId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).deleteWebhook(inboxId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * List inboxes in paginated form
     * @summary List Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getAllInboxes(page?: number, size?: number, options?: any) {
        return InboxControllerApiFp(this.configuration).getAllInboxes(page, size, options)(this.fetch, this.basePath);
    }

    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary List Emails in an Inbox / EmailAddress
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by descending received date time
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, options?: any) {
        return InboxControllerApiFp(this.configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, options)(this.fetch, this.basePath);
    }

    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox / EmailAddress
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).getInbox(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxes(options?: any) {
        return InboxControllerApiFp(this.configuration).getInboxes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all WebHooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getWebhooks(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).getWebhooks(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * Send an email from the inbox's email address. Specify the email recipients and contents in the request body. See the `SendEmailOptions` for more information. Note the `inboxId` refers to the inbox's id NOT its email address
     * @summary Send Email
     * @param {string} inboxId inboxId
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmail(inboxId: string, sendEmailOptions: SendEmailOptions, options?: any) {
        return InboxControllerApiFp(this.configuration).sendEmail(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    }

}

